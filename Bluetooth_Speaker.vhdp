Main
(

    Next_Btn    : IN     STD_LOGIC;  --Next Song
    Prev_Btn    : IN     STD_LOGIC;  --Last Song
    Pause_Btn   : IN     STD_LOGIC;  --Play/Pause
    Next_LED    : OUT    STD_LOGIC;  --Right LED
    Prev_LED    : OUT    STD_LOGIC;  --Left LED
    Pause_LED   : OUT    STD_LOGIC;  --Middle LED
    
    Audio_MCLK  : OUT    STD_LOGIC;  --Master Clock
    Audio_IRQ   : IN     STD_LOGIC;  --Interrupt
    Audio_SDA   : INOUT  STD_LOGIC;  --I2C Data
    Audio_SCL   : INOUT  STD_LOGIC;  --I2C Clock
    Audio_BCLK  : IN     STD_LOGIC;  --I2S Bit Clock
    Audio_LRCLK : IN     STD_LOGIC;  --I2S Left/Right Clock
    Audio_SDOUT : IN     STD_LOGIC;  --I2S ADC Data
    Audio_SDIN  : OUT    STD_LOGIC;  --I2S DAC Data
    
    Bluetooth_LRCLK  : OUT STD_LOGIC := '0';
    Bluetooth_BCLK   : OUT STD_LOGIC := '0';
    Bluetooth_Data   : IN  STD_LOGIC := '0';
    Bluetooth_Next   : Out STD_LOGIC := '0';
    Bluetooth_Prev   : Out STD_LOGIC := '0';
    Bluetooth_Pause  : Out STD_LOGIC := '0';

    LED_Strip_Out    : BUFFER STD_LOGIC;
    
)
{

--Buttons------------------------------------------------------------------------------------------

    Process ()
    {
        Thread
        {
            While((Next_Btn OR Prev_Btn OR Pause_Btn) = '1')  { Wait(100ms); } --Wait until Button released
            While((Next_Btn AND Prev_Btn AND Pause_Btn) = '0'){ Wait(100ms); } --Wait for Button pressed
            VARIABLE btn_reg : STD_LOGIC_VECTOR(2 downto 0);
            btn_reg(0) := Next_Btn;  --Save values in case the button isn't pressed any more
            btn_reg(1) := Prev_Btn;
            btn_reg(2) := Pause_Btn;
            --Simulate double click for bluetooth module (one click is vol up/down). Single click for Pause
            For(VARIABLE ctr : NATURAL range 0 to 2 := 0; ctr < 2 OR btn_reg(2) = '1'; ctr := ctr + 1)
            {
                Bluetooth_Next  <= btn_reg(0);
                Bluetooth_Prev  <= btn_reg(1);
                Bluetooth_Pause <= btn_reg(2);
                Wait(200ms);
                Bluetooth_Next <= '0';
                Bluetooth_Prev <= '0';
                Wait(200ms);
            }
        }
    }
    
--LEDs---------------------------------------------------------------------------------------------
    
    Process ()
    {
        VARIABLE Inc_Brightness : STD_LOGIC_VECTOR(2 downto 0) := "000";
        VARIABLE Trig           : STD_LOGIC_VECTOR(2 downto 0) := "000";
        Thread  --Wait for left button pressed
        {
            While(ISSP_source(1) = '1'){ Wait(100ms); } --Wait until Button released
            While(ISSP_source(1) = '0'){ Wait(100ms); } --Wait for Button pressed
            Inc_Brightness(0) := '1';
            Trig(0) := '1';
            ctr0 := 0;
        }
        Thread  --Wait for middle button pressed
        {
            While(Pause_Btn = '1'){ Wait(100ms); } --Wait until Button released
            While(Pause_Btn = '0'){ Wait(100ms); } --Wait for Button pressed
            Inc_Brightness(1) := '1';
            Trig(1) := '1';
            ctr1 := 0;
        }
        Thread  --Wait for right button pressed
        {
            While(ISSP_source(2) = '1'){ Wait(100ms); } --Wait until Button released
            While(ISSP_source(2) = '0'){ Wait(100ms); } --Wait for Button pressed
            Inc_Brightness(2) := '1';
            Trig(2) := '1';
            ctr2 := 0;
        }
        Thread  --Light Effect for left button
        {
            While(Inc_Brightness(0) = '0')
            {
                If(UNSIGNED(LED_Brightness(0)) > 0)
                {
                    LED_Brightness(0) <= STD_LOGIC_VECTOR(UNSIGNED(LED_Brightness(0)) - 1);
                    Wait(400us);
                }
            }
            For(VARIABLE ctr0 : NATURAL range 0 to 256 := 0; ctr0 < 256; ctr0 := ctr0 + 1)
            {
                If(UNSIGNED(LED_Brightness(0)) < 255)
                {
                    LED_Brightness(0) <= STD_LOGIC_VECTOR(UNSIGNED(LED_Brightness(0)) + 1);
                }
                If(ctr0 = 127 AND Trig(0) = '1')
                {
                    Inc_Brightness(1) := '1';
                }
                If(ctr0 = 255 AND Trig(0) = '1')
                {
                    Inc_Brightness(2) := '1';
                }
                Wait(600us);
            }
            Inc_Brightness(0) := '0';
            Trig(0) := '0';
        }
        Thread  --Light Effect for middle button
        {
            While(Inc_Brightness(1) = '0')
            {
                If(UNSIGNED(LED_Brightness(1)) > 0)
                {
                    LED_Brightness(1) <= STD_LOGIC_VECTOR(UNSIGNED(LED_Brightness(1)) - 1);
                    Wait(400us);
                }
            }
            For(VARIABLE ctr1 : NATURAL range 0 to 256 := 0; ctr1 < 256; ctr1 := ctr1 + 1)
            {
                If(UNSIGNED(LED_Brightness(1)) < 255)
                {
                    LED_Brightness(1) <= STD_LOGIC_VECTOR(UNSIGNED(LED_Brightness(1)) + 1);
                }
                If(ctr1 = 127 AND Trig(1) = '1')
                {
                    Inc_Brightness(0) := '1';
                    Inc_Brightness(2) := '1';
                }
                Wait(600us);
            }
            Inc_Brightness(1) := '0';
            Trig(1) := '0';
        }
        Thread  --Light Effect for right button
        {
            While(Inc_Brightness(2) = '0')
            {
                If(UNSIGNED(LED_Brightness(2)) > 0)
                {
                    LED_Brightness(2) <= STD_LOGIC_VECTOR(UNSIGNED(LED_Brightness(2)) - 1);
                    Wait(400us);
                }
            }
            For(VARIABLE ctr2 : NATURAL range 0 to 256 := 0; ctr2 < 256; ctr2 := ctr2 + 1)
            {
                If(UNSIGNED(LED_Brightness(2)) < 255)
                {
                    LED_Brightness(2) <= STD_LOGIC_VECTOR(UNSIGNED(LED_Brightness(2)) + 1);
                }
                If(ctr2 = 127 AND Trig(2) = '1')
                {
                    Inc_Brightness(1) := '1';
                }
                If(ctr2 = 255 AND Trig(2) = '1')
                {
                    Inc_Brightness(0) := '1';
                }
                Wait(600us);
            }
            Inc_Brightness(2) := '0';
            Trig(2) := '0';
        }
    }
    
    --When button pressed -> LED lights up and wave goes trough leds next to it
    SIGNAL LED_reg : STD_LOGIC_VECTOR(2 downto 0);
    Prev_LED  <= LED_reg(0);
    Pause_LED <= LED_reg(1);
    Next_LED  <= LED_reg(2);
    
    TYPE LED_Brightness_type IS ARRAY (0 to 2) OF STD_LOGIC_VECTOR(7 downto 0);
    SIGNAL LED_Brightness : LED_Brightness_type;
    
    Generate (for i in 0 to 2)
    {
        NewComponent PWM_Generator
        (
            Duty            => LED_Brightness(i),
            PWM_Out(0)      => LED_reg(i),
        );
    }
    
--LED Strip----------------------------------------------------------------------------------------
    
    CONSTANT LEDs : NATURAL := 50;
    
    CONSTANT Colors : NATURAL := 6;
    TYPE Colors_type IS ARRAY (0 to Colors-1) OF STD_LOGIC_VECTOR(23 downto 0);
    CONSTANT Colors_Arr : Colors_type :=
    (
        x"FF0000",
        x"7F7F00",
        x"00FF00",
        x"007F7F",
        x"0000FF",
        x"7F007F"
    );
    
    --TODO: Find current average and maximum in last second
    Process ()
    {
        Thread
        {
            For(VARIABLE color : NATURAL range 0 to Colors := 0; color < Colors; color := color + 1)
            {
                Wait(1s);
            }
        }
        
        VARIABLE vol : NATURAL range 0 to 31;
        vol := TO_INTEGER(Audio_Vol(12 downto 8));
        if(vol > 24) { vol := 24; }
        
        If(LED_Strip_Address >= 24-vol AND LED_Strip_Address <= 25+vol)
        {
            LED_Strip_Pixel <= Colors_Arr(color);
        }
        Else
        {
            LED_Strip_Pixel <= x"000000";
        }
    }
    
    SIGNAL LED_Strip_Update           : STD_LOGIC;
    SIGNAL LED_Strip_Pixel_CLK        : STD_LOGIC;
    SIGNAL LED_Strip_Address          : NATURAL          range 0 to LEDs-1;
    SIGNAL LED_Strip_Pixel            : STD_LOGIC_VECTOR (23 downto 0) := x"FF00FF";
    NewComponent WS2812_Interface
    (
        CLK_Frequency => 12000000,
        LEDs          => LEDs,

        Update        => LED_Strip_Update,
        Data_Out      => LED_Strip_Out,
        Pixel_CLK     => LED_Strip_Pixel_CLK,
        Address       => LED_Strip_Address,
        Pixel         => LED_Strip_Pixel,
    );
    
--Channel Watcher----------------------------------------------------------------------------------
    
    SIGNAL Bluetooth_Out : STD_LOGIC := '1';
    Process ()
    {
        Thread
        {
            VARIABLE analog_sum    : SIGNED (16 downto 0);
            VARIABLE analog_dif    : UNSIGNED (16 downto 0);
            VARIABLE analog_min    : SIGNED (16 downto 0);
            VARIABLE analog_max    : SIGNED (16 downto 0);
            VARIABLE bluetooth_sum : SIGNED (16 downto 0);
            VARIABLE bluetooth_dif : UNSIGNED (16 downto 0);
            VARIABLE bluetooth_min : SIGNED (16 downto 0);
            VARIABLE bluetooth_max : SIGNED (16 downto 0);
            SIGNAL Audio_Vol       : UNSIGNED (16 downto 0);
            --Check 1000 samples and calculate the amplitude -> The louder signal is played
            For(VARIABLE ctr : NATURAL range 0 to 500 := 0; ctr < 500; ctr := ctr + 1)
            {
                bluetooth_sum := resize(SIGNED(Bluetooth_Data_L), 17) + resize(SIGNED(Bluetooth_Data_R), 17);
                If(ctr = 0)
                {
                    bluetooth_min := bluetooth_sum;
                    bluetooth_max := bluetooth_sum;
                }
                Elsif(bluetooth_sum < bluetooth_min)
                {
                    bluetooth_min := bluetooth_sum;
                }
                Elsif(bluetooth_sum > bluetooth_max)
                {
                    bluetooth_max := bluetooth_sum;
                }
                
                analog_sum := resize(Audio_Codec_Component_ADC_L, 17) + resize(Audio_Codec_Component_ADC_R, 17);
                If(ctr = 0)
                {
                    analog_min := analog_sum;
                    analog_max := analog_sum;
                }
                Elsif(analog_sum < analog_min)
                {
                    analog_min := analog_sum;
                }
                Elsif(analog_sum > analog_max)
                {
                    analog_max := analog_sum;
                }
                
                Wait(30us);
            }
            
            analog_dif    := unsigned(abs(resize(analog_max, 18) - resize(analog_min, 18)))(16 downto 0);
            bluetooth_dif := unsigned(abs(resize(bluetooth_max, 18) - resize(analog_min, 18)))(16 downto 0);
            If(analog_dif > bluetooth_dif+500)
            {
                --Bluetooth_Out <= '0';
                Audio_Vol <= analog_dif;
            }
            Else
            {
                --Bluetooth_Out <= '1';
                Audio_Vol <= bluetooth_dif;
            }
            
            Wait(2);
            LED_Strip_Update <= '1';
            Wait(1);
            LED_Strip_Update <= '0';
        }
    }
    
--Volume-------------------------------------------------------------------------------------------
    
    SIGNAL Volume    : NATURAL range 0 to 4095 := 0;
    NewComponent ADC_MAX10_Single
    (
        Channel => 0,
        Data    => Volume,
    );
    
--Mixer--------------------------------------------------------------------------------------------
    
    Audio_Codec_Component_DAC_L <= SIGNED(Bluetooth_Data_L) when Bluetooth_Out = '1' else Audio_Codec_Component_ADC_L;
    Audio_Codec_Component_DAC_R <= SIGNED(Bluetooth_Data_R) when Bluetooth_Out = '1' else Audio_Codec_Component_ADC_R;
    
--Bluetooth----------------------------------------------------------------------------------------
    
    SIGNAL Bluetooth_Data_L             : STD_LOGIC_VECTOR (16-1 downto 0) := (others => '0');
    SIGNAL Bluetooth_Data_R             : STD_LOGIC_VECTOR (16-1 downto 0) := (others => '0');
    SIGNAL Bluetooth_Ready              : STD_LOGIC := '0';

    NewComponent I2S_Interface_IN
    (
        CLK_Frequency      => 12000000,
        Sampling_Frequency => 32000,
        Data_Width         => 16,
        Sample_Bits        => 16,
        BCLK_Edge          => '1',

        LRCLK              => Bluetooth_LRCLK,
        BCLK               => Bluetooth_BCLK,
        Data               => Bluetooth_Data,
        Data_L             => Bluetooth_Data_L,
        Data_R             => Bluetooth_Data_R,
        Ready              => Bluetooth_Ready,
    );
    
    --ISSP_probe <= Bluetooth_Data_L & STD_LOGIC_VECTOR(Audio_Codec_Component_ADC_L);
    ISSP_probe(16 downto 0) <= STD_LOGIC_VECTOR(Audio_Vol);
    Bluetooth_Out <= ISSP_source(0);
    
    SIGNAL ISSP_source : std_logic_vector (7 downto 0);
    SIGNAL ISSP_probe  : std_logic_vector (31 downto 0) := (others => 'X');
    NewComponent ISSP
    (
        source =>ISSP_source,
        probe  =>ISSP_probe,
    );

--Audio Out and Line In----------------------------------------------------------------------------

    SIGNAL Audio_Codec_Component_ADC_L : SIGNED  (15 downto 0);
    SIGNAL Audio_Codec_Component_ADC_R : SIGNED  (15 downto 0);
    SIGNAL Audio_Codec_Component_DAC_L : SIGNED  (15 downto 0);
    SIGNAL Audio_Codec_Component_DAC_R : SIGNED  (15 downto 0);

    NewComponent MAX9867_Interface
    (
        Microphone_Ena   => false,   --Use microphone as ADC input
        Line_In_Ena      => true,    --Use line in as ADC input
        Differential_Out => false,   --false for audio jack
        
        Line_In_Gain => 0,
        ADC_Volume   => 0,
        
        Reset => '0',
        IRQ   => Audio_IRQ,
        SDA   => Audio_SDA,
        SCL   => Audio_SCL,
        MCLK  => Audio_MCLK,
        BCLK  => Audio_BCLK,
        LRCLK => Audio_LRCLK,
        SDOUT => Audio_SDOUT,
        SDIN  => Audio_SDIN,
        ADC_L => Audio_Codec_Component_ADC_L,
        ADC_R => Audio_Codec_Component_ADC_R,
        DAC_L => Audio_Codec_Component_DAC_L,
        DAC_R => Audio_Codec_Component_DAC_R,
    );
}
